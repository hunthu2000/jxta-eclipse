/*
 *  Copyright (c) 2001-2007 Sun Microsystems, Inc.  All rights reserved.
 *
 *  The Sun Project JXTA(TM) Software License
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  3. The end-user documentation included with the redistribution, if any, must
 *     include the following acknowledgment: "This product includes software
 *     developed by Sun Microsystems, Inc. for JXTA(TM) technology."
 *     Alternately, this acknowledgment may appear in the software itself, if
 *     and wherever such third-party acknowledgments normally appear.
 *
 *  4. The names "Sun", "Sun Microsystems, Inc.", "JXTA" and "Project JXTA" must
 *     not be used to endorse or promote products derived from this software
 *     without prior written permission. For written permission, please contact
 *     Project JXTA at http://www.jxta.org.
 *
 *  5. Products derived from this software may not be called "JXTA", nor may
 *     "JXTA" appear in their name, without prior written permission of Sun.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
 *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 *  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SUN
 *  MICROSYSTEMS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *  JXTA is a registered trademark of Sun Microsystems, Inc. in the United
 *  States and other countries.
 *
 *  Please see the license information page at :
 *  <http://www.jxta.org/project/www/license.html> for instructions on use of
 *  the license in source files.
 *
 *  ====================================================================
 *
 *  This software consists of voluntary contributions made by many individuals
 *  on behalf of Project JXTA. For more information on Project JXTA, please see
 *  http://www.jxta.org.
 *
 *  This license is based on the BSD license adopted by the Apache Foundation.
 */

package org.eclipselabs.jxse.ui.monitor;

import java.util.Collections;
import java.util.List;
import javax.swing.JPanel;
import javax.swing.table.DefaultTableModel;

/**
 * This frame collects and displays connectivity information from a peergroup.
 */
public class ConnectivityStatusPanel extends JPanel {

    // Static

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable LocalEdgeTable;
    private javax.swing.JTable LocalRDVTable;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables


    private DefaultTableModel LocalRDVs_TM = null;
    private String[] LocalRDV_Col = { "Local RDV View IDs" };

    private DefaultTableModel LocalEdges_TM = null;
    private String[] LocalEdge_Col = { "Local EDGE View IDs" };

    private static final String[][] EmptyTableContent = new String[0][1];

    /** Creates new form ConnectivityMonitor */
    public ConnectivityStatusPanel() {
        initComponents();

        // Setting own default table models
        LocalRDVs_TM = new DefaultTableModel(EmptyTableContent, LocalRDV_Col);
        this.LocalRDVTable.setModel(LocalRDVs_TM);

        LocalEdges_TM = new DefaultTableModel(EmptyTableContent, LocalEdge_Col);
        this.LocalEdgeTable.setModel(LocalEdges_TM);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        LocalEdgeTable = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        LocalRDVTable = new javax.swing.JTable();

        javax.swing.GroupLayout StatusPaneLayout = new javax.swing.GroupLayout(this);
        this.setLayout(StatusPaneLayout);
        StatusPaneLayout.setHorizontalGroup(
            StatusPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, StatusPaneLayout.createSequentialGroup()
                .addContainerGap()
        ));
        StatusPaneLayout.setVerticalGroup(
            StatusPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(StatusPaneLayout.createSequentialGroup()
                .addContainerGap()
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGap(18, 18, 18)
        ));

        LocalEdgeTable.setFont(new java.awt.Font("Tahoma", 0, 9));
        LocalEdgeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null}
            },
            new String [] {
                "Local Edge View IDs"
            }
        ) {
            /**
			 * 
			 */
			private static final long serialVersionUID = 1L;
			Class<?>[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            @Override
			public Class<?> getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            @Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        LocalEdgeTable.getColumnModel().getColumn(0).setResizable(false);
        LocalRDVTable.setFont(new java.awt.Font("Tahoma", 0, 9));
        LocalRDVTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null}
            },
            new String [] {
                "Local RDV View IDs"
            }
        ) {
            /**
			 * 
			 */
			private static final long serialVersionUID = 1L;
			Class<?>[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            @Override
			public Class<?> getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            @Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(LocalRDVTable);
        LocalRDVTable.getColumnModel().getColumn(0).setResizable(false);
    }// </editor-fold>//GEN-END:initComponents

    void updateRDVs( List<String> inNewContent ){
    	this.updateTableContent(LocalRDVs_TM, inNewContent, LocalRDV_Col );
    }

    void updateEdges( List<String> inNewContent ){
    	this.updateTableContent(LocalEdges_TM, inNewContent, LocalEdge_Col );
    }

    private void updateTableContent(DefaultTableModel inTM, List<String> inNewContent, String[] inColumns) {
        // Do we have the same number of elements
        if ( inTM.getRowCount() == inNewContent.size() ) {
            // Sorting new candidates
            Collections.sort(inNewContent);

            // Replacing items that have to be replaced
            for (int i=0;i<inNewContent.size();i++) {
                if ( inNewContent.get(i).compareTo((String) inTM.getValueAt(i, 0)) != 0 )
                    inTM.setValueAt(inNewContent.get(i), i, 0);
            }
            // Done
            return;
        }

        // We need a new data vector
        String[][] NewContent = new String[inNewContent.size()][1];
        for (int i=0;i<inNewContent.size();i++) NewContent[i][0] = inNewContent.get(i);
        inTM.setDataVector(NewContent, inColumns);
    }
}
